# SwoleGator Beta Build

## Project Summary
At the time of the Beta Build, the SwoleGator device accurately measures velocity, repetition count, and maximum velocity of the motion done by a weightlifter. The user can calibrate their device with the push of a button, where the orientation of the device is detected and the user’s maximum velocity per exercise is calculated. The device communicates this data to the SwoleGator application through Bluetooth Low Energy (BLE) to be displayed and stored in the user's profile. The app features functional profile login and logout, the ability to view a user's profile, connect to the SwoleGator device through BLE, and view lift data in real time. The application also features a social environment, where users can post their lifts to be viewed and shared by friends or trainers. In addition, a user can visualize their workout data graph over a certain period of time. 

## Navigation & Other Useful Instructions
The application opens to a login screen, where the user can choose to log in with an existing account or create a new account. Once either of these actions is completed, the user is taken to a home screen. On this screen, the user should connect to the hardware device using the top button, titled "Connect device". This is as simple as clicking "scan for devices" and then clicking on the SwoleGator option when it pops up. The application will only display a compatible SwoleGator device to avoid connections to extraneous Bluetooth devices in the area. Once connected, the SwoleGator button will change colors, showing a successful connection. The user can then go back to the home screen and navigate to "start lift", where they will choose an exercise type and follow instructions for calibration, and then begin their lift and view lift data in real-time. If extraneous movements are recorded, or the user wants to get rid of a set that they failed or otherwise does not want to save, there is a “restart workout” option available to restart all measurements to 0. Once a lift has been completed, the user can return to the home screen once again and view their profile to see all past lift data. They can also choose friends’ profiles, listed in the “Friends” section of their own profile, to see other users’ public workouts. The final button is a logout option, which is self-explanatory to users.



## Beta Build Required Components

### Usability

#### Interface
All interface elements have been implemented and are accessible. At this point, the UI is entirely contained in the software elements, with an intuitive React Native app that connects to the hardware remotely over BLE. For our interface elements, we have a login/sign-up page where users can input their credentials, which are later stored in (or checked against) a Firebase database once the submit button is pressed. We have also created a page where the user can select (by clicking a button) what type of exercise they want to start performing. The app incorporates a page where the user can connect to the device over BLE with a simple click of a button and, once connected, it will visually alert the user by changing to a different color. Once connected and after device calibration, the user clearly visualizes their maximum velocity, the current repetition count of their exercise session, and the current velocity at which they are doing the exercise they selected previously. In addition to these, a social page was created where users can add friends to network and share their fitness progress with them. The app has a simple login and usage interface, with clear buttons and responses like any other app. In addition, a persistent state is evident in the highlight of buttons (such as when the user presses the button to connect the ESP32 to the app with the button remaining a darker color) and pages on the app such as the graphing consistently sending calls to update and display data.

#### Navigation
The app begins at the login state if the user is not previously logged in on their device and the user can log in/sign up and navigate between functional screens, including pages like selecting exercise types, starting lift (where they can see their current data), connecting to the device through BLE, accessing their social pages, or logging out and navigating back and forth between these. This is all built to be easily understood and accessible to users. Progress has been made from an ongoing bug related to delayed response to button presses, and should be improved as we continue to improve the rendering of screens. Every feature is easily discovered from the home page. Popups are also in the process of being improved to make errors more easily understood by users.

#### Perception
The app and device are intuitive and easy to use for the intended purpose. The context of logging in, connecting to the device, selecting the exercise, and beginning the lift is logical and easy to follow. The continuous data received over BLE is clearly labeled and shown to avoid user confusion while performing exercises. The interface buttons have clear labels to indicate the page they refer to for simplified user navigation, and the only physical interaction required for the hardware is turning the battery on/off and using a calibration button, which are simple and straight forward. Application state changes with logged-in users/guests, as well as connected and disconnected devices being persistently accessible on the "connect device" screen.

#### Responsiveness
So far in the building of our application, no busy wait loops have been discovered. The Bluetooth search feature continues for a defined amount of time and displays that it is searching until it finishes, reducing confusion from the user and prolonged waits. Once the device connects over BLE, a calibration period of 30 seconds can be triggered with the push of a button, where the device orientation is detected and the users perform exercise reps to calculate their maximum velocity and threshold. The period start and finish of the calibration is indicated to the user with alert messages. Any delay in rendering graphs does not affect the transition to the correct page for the user, only in adding data to the page. 

### Build Quality 
#### Robustness
No major crashes or glitches are apparent in this build. The app connects to BLE for an extended period and can continuously receive and store data, as well as display the data on the app screens. Taking graphing out of the live workouts prevented the data from appearing corrupted, and improved accuracy of repetition count. Any delay from rendering does not block background processes and is being improved upon as data display is optimized. In addition, Bluetooth calls between software and hardware do not cause any waiting loops, even if the connection breaks.

#### Consistency
There is consistency in the software aspects of logins and app behavior in our build. The app will predictably find our device to connect to, and only our device. The hardware can be calibrated with the push of a button to ensure consistency and accuracy in measurements from the IMU taking into account the pace of the user and the orientation of the device. This being said the reliability of the IMU is not perfect due to the nature of the sensors. Even though velocity calculations inevitably accumulate errors over time, we have managed to reduce these errors by automatically resetting data arrays on the Arduino IDE program of our device after obtaining 10 velocity values. Due to these error-prone readings, further integration of the velocity to find position will introduce additional errors, which is why we have prevented the expansion of such a feature. For the next milestone, our goal is to use the orientation detection algorithm of our device to detect possible dangerous movements performed by the user. There is proven consistency shown in our data storage in firebase, where logins and adding friends/ tracking workouts are shown to be reliable and consistent.

#### Aesthetic Rigor
No major cosmetic software issues are currently present. The app successfully displays useful values to the user, including maximum velocity, current repetition count, and current velocity. As for the physical artifact, we have 3D printed a case for a compacted device that can be attached to the weight bar. The next step will be to test the case and make any edits to ensure it is adaptable to a wide variety of workout equipment.

### Vertical Features

#### External Interface
* User Profiles can be created, accessed, and logged in or out of the persistent state using Google Firebase’s authorization API. The profile is visible and will contain historical lift data. If logged in, the app acknowledges the user by name and otherwise displays a guest message. 
* Social features are accessible through the profile and allow for display of workout data from friends in the same format as personal workout data.
* Exercise Type & Calibration is visible on the external interface and will remain as the lift is performed and data is gathered that is then stored to profile for future use. These options are shown as the user chooses the begin lift option. Exercise type is selected after starting a lift. Once the lift is started, the calibration can be triggered with the push of a button. During the calibration, the user performs the exercise at their regular pace for 30 seconds, during which a maximum velocity and threshold will be calculated as well as the orientation of the device. The threshold is used to then determine when a repetition has occurred post-calibration.
* Maximum Velocity, Repetition Count, & Current Velocity are displayed in the app as the lift is in progress, giving the user useful feedback on their exercise. This is stored in a persistent state (Firebase database) for future use and analysis. This data is shown in a more visual format on the profile in historical lifts and is shown in a basic format during live exercises.
* Device Connection to the physical hardware is performed on one screen and remains as other screens are navigated to and data is gathered and displayed.  

#### Persistent State
* User Profiles are stored in Firebase so that an account created in one use of the app can be accessed and edited for future use. The data is not wiped after each lift but instead stored so that profiles can be useful in the long term to show trends. User profiles are processed within the software's internal systems.
* Friends are stored within firebase in the same way as other profile data, and the user is able to add friends that remain on their profile in a persistent state, rather than being wiped after each session.
* Exercise Type & Calibration Data such as the maximum velocity and the device orientation are stored as they affect the way that velocity is measured within internal systems and the users' goals. For example, the maximum velocity obtained from calibration is later used to calculate the threshold value for repetition counting. For the next milestone, this maximum velocity will also serve to offer recommendations to the user to either increase or decrease the weight. This data is stored in the Firebase database in a persistent state as well, to show specific trends per exercise. 
* Maximum Velocity & Repetition Count is stored in the profiles as well as exercise type, again to see trends and improvement over time, which is the main usefulness of our device- to track improvement (or any change) over time and assess their fitness. This data is calculated in internal systems based on sensors within the hardware.
* Device connection to the physical hardware is persistent; once connected, the chip showing the SwoleGator device name remains a different color. We hope to eventually implement an icon that is visible on all screens of the app to show this state, which will take place as a process in internal systems.

#### Internal Systems
* User Profiles are processed within the software communicating with Firebase, allowing for the account creation, logging in, and logging out. The profile can remain logged in on the same device by storing the profile in the internal systems of the software. Ideally, the app will also display goals and recommendations with this saved data in the future.
* Social features allow users to view their friends progress, and are calculated in the same way as the logged-in user’s. There is an internal system that only allows users to see their friends’ public workouts, in a visual format the same as their own.
* Exercise Type & Calibration change how velocity is processed and repetitions are counted. For example, different exercises have different directions of velocity that are important and will have different goals over time. The calibration is triggered at any time with the push of a button and runs for 30 seconds where the device orientation is detected based on accelerometer values. During calibration, the user performs the chosen exercise type at their regular pace. During such period, maximum velocity and orientation are calculated. The maximum velocity is then used to calculate a threshold value using the equation (max v + min v) / 2, which is then used to detect exercise repetitions. For example, if the current velocity is above the threshold, the above threshold state is changed to true and the repetition counter is increased. We have successfully implemented velocity calculations in any device orientation. For this to work, the user must perform a calibration prior to exercising to detect the orientation of the device and calculate the velocity accordingly. 
* Maximum Velocity & Repetition Count is performed, along with calibration, on the Arduino IDE side on the hardware. This data is then sent to the application through BLE to be displayed and stored, as well as analyzed to allow the user to create and track goals. We have also added a calibration flag that is sent through BLE and lets the app know when the calibration has started/ended. As the app is perfected there will ideally be more calculations performed on the data with different exercises to give recommendations.
* Device connection between the application and ESP32 is handled through BLE connection code in the software and attributes given on the hardware side. It is stored in a persistent state and used to display to the user the connection, and whether or not this connection has been broken, which is processed through the internal systems.
* Velocity Calculation is performed via an algorithm on the device’s Arduino IDE program. A moving average filter smoothes out the accelerometer data from the MPU6050 to prevent noisy data. After filtering, the rate of change is calculated by using the equation Vf = Vi + at, where Vf is the current velocity, Vi is the previous velocity, a is the filtered acceleration, and t is time (1 ms). Current velocities are stored in an array of 10 values which then gets cleared after filled to prevent accumulative errors from acceleration integration. The velocity calculation is dependent on the orientation of the device, which affects what accelerometer component to read from (X, Y, or Z).